package ru.tinkoff.coursework.sentry.database

import cats._
import cats.data._
import cats.effect._
import doobie._
import cats.implicits._
import com.typesafe.scalalogging.LazyLogging
import doobie.implicits._
import doobie.postgres._
import doobie.postgres.implicits._
import doobie.implicits.javasql._
import doobie.implicits.legacy.instant._
import doobie.implicits.legacy.localdate._
import doobie.util.transactor.Transactor.Aux
import ru.tinkoff.coursework.sentry.entities.{FailureEntity, JobEntity, ServiceEntity, UserEntity}

import java.sql.Timestamp

class SentryDatabaseImpl extends SentryDatabase with LazyLogging {

  val xa: Aux[IO, Unit] = Transactor.fromDriverManager[IO](
    "org.postgresql.Driver",
    "jdbc:postgresql://127.0.0.1:5432/postgres",
    "postgres",
    "postgres"
  )
  val failureDAO = new FailureDAOImpl(xa)
  val jobDAO = new JobDAOImpl(xa)
  val serviceDAO = new ServiceDAOImpl(xa)
  val tagDAO = new TagDAOImpl(xa)
  val userDAO = new UserDAOImpl(xa)
  val telegramDAO = new TelegramDAOImpl(xa)
  val userScheme: IO[Int] =
    sql"""
      CREATE TABLE IF NOT EXISTS userTable (
        userId bigint NOT NULL PRIMARY KEY,
        username VARCHAR NOT NULL,
        mail VARCHAR,
        cellphone VARCHAR
        )
       """.update.run.transact(xa)

  val userTagScheme: IO[Int] =
    sql"""
      CREATE TABLE IF NOT EXISTS userTagTable (
        id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        userId bigint NOT NULL,
        tag VARCHAR NOT NULL,
        FOREIGN KEY (userId)  REFERENCES userTable (userId)
        )
       """.update.run.transact(xa)

  val serviceScheme: IO[Int] =
    sql"""
      CREATE TABLE IF NOT EXISTS serviceTable (
        serviceId bigint NOT NULL PRIMARY KEY,
        URL VARCHAR NOT NULL)
   """.update.run.transact(xa)

  val serviceTagScheme: IO[Int] =
    sql"""
      CREATE TABLE IF NOT EXISTS serviceTagTable (
        id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        serviceId bigint NOT NULL,
        tag VARCHAR NOT NULL,
        FOREIGN KEY (serviceId)  REFERENCES serviceTable (serviceId)
        )
       """.update.run.transact(xa)

  val serviceUserSubscribeScheme: IO[Int] =
    sql"""
      CREATE TABLE IF NOT EXISTS serviceUserTable (
        id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        userId bigint NOT NULL,
        serviceId bigint NOT NULL)
       """.update.run.transact(xa)

  val failureScheme: IO[Int] =
    sql"""
      CREATE TABLE IF NOT EXISTS failureTable (
        failureId bigint NOT NULL PRIMARY KEY,
        URL VARCHAR NOT NULL,
        description VARCHAR,
        failureTime TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
      )
   """.update.run.transact(xa)

  val jobScheme: IO[Int] =
    sql"""
      CREATE TABLE IF NOT EXISTS jobTable (
        jobId bigint NOT NULL PRIMARY KEY,
        serviceId bigint NOT NULL,
        description VARCHAR,
        startTime TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
        endTime TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
      )
   """.update.run.transact(xa)

  val jobUserScheme: IO[Int] =
    sql"""
      CREATE TABLE IF NOT EXISTS jobUserTable (
        id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        userId bigint NOT NULL,
        jobId bigint NOT NULL,
        FOREIGN KEY (jobId) REFERENCES jobTable (jobId)
        )
       """.update.run.transact(xa)

  val userWithTelegramChatScheme: IO[Int] =
    sql"""
      CREATE TABLE IF NOT EXISTS userWithTelegramChatTable (
        sentryId bigint PRIMARY KEY,
        chatId bigint NOT NULL,
        FOREIGN KEY (sentryId) REFERENCES userTable (userId)
        )
       """.update.run.transact(xa)

  val dropUserTable: IO[Int] = sql"""DROP TABLE IF EXISTS userTable CASCADE""".update.run.transact(xa)
  val dropUserTagTable: IO[Int] = sql"""DROP TABLE IF EXISTS userTagTable CASCADE""".update.run.transact(xa)
  val dropServiceTable: IO[Int] = sql"""DROP TABLE IF EXISTS serviceTable CASCADE""".update.run.transact(xa)
  val droServiceTagTable: IO[Int] = sql"""DROP TABLE IF EXISTS serviceTagTable CASCADE""".update.run.transact(xa)
  val dropServiceUserTable: IO[Int] = sql"""DROP TABLE IF EXISTS serviceUserTable CASCADE""".update.run.transact(xa)
  val dropFailureTable: IO[Int] = sql"""DROP TABLE IF EXISTS failureTable CASCADE""".update.run.transact(xa)
  val dropJobTable: IO[Int] = sql"""DROP TABLE IF EXISTS jobTable CASCADE""".update.run.transact(xa)
  val dropJobUserTable: IO[Int] = sql"""DROP TABLE IF EXISTS jobUserTable CASCADE""".update.run.transact(xa)
  val dropUserWithTelegramUserTable: IO[Int] = sql"""DROP TABLE IF EXISTS userWithTelegramChatTable CASCADE""".update.run.transact(xa)
  val dropTables: IO[Unit] = for {
    _ <- dropUserTable
    _ <- dropUserTagTable
    _ <- dropServiceTable
    _ <- droServiceTagTable
    _ <- dropServiceUserTable
    _ <- dropFailureTable
    _ <- dropJobTable
    _ <- dropJobUserTable
    _ <- dropJobUserTable
    _ <- dropUserWithTelegramUserTable
  } yield ()

  override def createFailure(failure: FailureEntity): IO[Boolean] = failureDAO.createFailure(failure)

  override def findFailureById(id: Long): IO[Option[FailureEntity]] = failureDAO.findFailureById(id)

  override def createJob(userId: Long, jobEntity: JobEntity): IO[Boolean] = jobDAO.createJob(userId, jobEntity)

  override def findJobById(id: Long): IO[Option[JobEntity]] = jobDAO.findJobById(id)

  override def findUserById(id: Long): IO[Option[UserEntity]] = userDAO.findUserById(id)

  override def findUsersByTag(tag: String): IO[List[UserEntity]] = userDAO.findUsersByTag(tag)

  override def createUser(userEntity: UserEntity): IO[Boolean] = userDAO.createUser(userEntity)

  override def getUsersDutyInJobs(currentTime: Timestamp): IO[Set[UserEntity]] = userDAO.getUsersDutyInJobs(currentTime)

  override def getUsersByServiceId(serviceId: Long): IO[Set[UserEntity]] = userDAO.getUsersByServiceId(serviceId)

  override def getUsersByTags(tagList: Set[String]): IO[Set[UserEntity]] = userDAO.getUsersByTags(tagList)

  override def bindUserWithTelegramChat(sentryId: Long, chatId: Long): IO[Boolean] = telegramDAO.bindUserWithTelegramChat(sentryId, chatId)

  override def getChatByUserId(userId: Long): IO[Long] = telegramDAO.getChatByUserId(userId)

  override def createServiceTag(serviceId: Long, tag: String): IO[Boolean] = tagDAO.createServiceTag(serviceId, tag)

  override def createUserTag(userId: Long, tag: String): IO[Boolean] = tagDAO.createUserTag(userId, tag)

  override def getTagsByServiceId(serviceId: Long): IO[Set[String]] = tagDAO.getTagsByServiceId(serviceId)

  override def findServiceById(id: Long): IO[Option[ServiceEntity]] = serviceDAO.findServiceById(id)

  override def findServicesByTag(tag: String): IO[List[ServiceEntity]] = serviceDAO.findServicesByTag(tag)

  override def getServiceId(URL: String): IO[Option[Long]] = serviceDAO.getServiceId(URL)

  override def assignUserToService(userId: Long, serviceId: Long): IO[Boolean] = serviceDAO.assignUserToService(userId, serviceId)

  override def createService(service: ServiceEntity): IO[Boolean] = serviceDAO.createService(service)

}
