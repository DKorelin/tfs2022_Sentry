package ru.tinkoff.coursework.sentry.database

import cats.effect._
import com.typesafe.scalalogging.LazyLogging
import doobie.implicits._
import doobie.postgres._
import doobie.postgres.implicits._
import doobie.implicits.javasql._
import doobie.implicits.legacy.instant._
import doobie.implicits.legacy.localdate._
import doobie.util.transactor.Transactor.Aux
import java.sql.Timestamp

class Schemes(xa: Aux[IO, Unit]) extends LazyLogging {

  val failureDAO = new FailureDAOImpl(xa)
  val jobDAO = new JobDAOImpl(xa)
  val serviceDAO = new ServiceDAOImpl(xa)
  val tagDAO = new TagDAOImpl(xa)
  val userDAO = new UserDAOImpl(xa)
  val telegramDAO = new TelegramDAOImpl(xa)
  val userScheme: IO[Int] =
    sql"""
      CREATE TABLE IF NOT EXISTS userTable (
        userId bigint NOT NULL PRIMARY KEY,
        username VARCHAR NOT NULL,
        mail VARCHAR,
        cellphone VARCHAR
        )
       """.update.run.transact(xa)

  val userTagScheme: IO[Int] =
    sql"""
      CREATE TABLE IF NOT EXISTS userTagTable (
        id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        userId bigint NOT NULL,
        tag VARCHAR NOT NULL,
        FOREIGN KEY (userId)  REFERENCES userTable (userId)
        )
       """.update.run.transact(xa)

  val serviceScheme: IO[Int] =
    sql"""
      CREATE TABLE IF NOT EXISTS serviceTable (
        serviceId bigint NOT NULL PRIMARY KEY,
        URL VARCHAR NOT NULL)
   """.update.run.transact(xa)

  val serviceTagScheme: IO[Int] =
    sql"""
      CREATE TABLE IF NOT EXISTS serviceTagTable (
        id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        serviceId bigint NOT NULL,
        tag VARCHAR NOT NULL,
        FOREIGN KEY (serviceId)  REFERENCES serviceTable (serviceId)
        )
       """.update.run.transact(xa)

  val serviceUserSubscribeScheme: IO[Int] =
    sql"""
      CREATE TABLE IF NOT EXISTS serviceUserTable (
        id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        userId bigint NOT NULL,
        serviceId bigint NOT NULL)
       """.update.run.transact(xa)

  val failureScheme: IO[Int] =
    sql"""
      CREATE TABLE IF NOT EXISTS failureTable (
        failureId bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        URL VARCHAR NOT NULL,
        description VARCHAR,
        failureTime TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
      )
   """.update.run.transact(xa)

  val jobScheme: IO[Int] =
    sql"""
      CREATE TABLE IF NOT EXISTS jobTable (
        jobId bigint NOT NULL PRIMARY KEY,
        serviceId bigint NOT NULL,
        description VARCHAR,
        startTime TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
        endTime TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
      )
   """.update.run.transact(xa)

  val jobUserScheme: IO[Int] =
    sql"""
      CREATE TABLE IF NOT EXISTS jobUserTable (
        id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        userId bigint NOT NULL,
        jobId bigint NOT NULL,
        FOREIGN KEY (jobId) REFERENCES jobTable (jobId)
        )
       """.update.run.transact(xa)

  val userWithTelegramChatScheme: IO[Int] =
    sql"""
      CREATE TABLE IF NOT EXISTS userWithTelegramChatTable (
        sentryId bigint PRIMARY KEY,
        chatId bigint NOT NULL,
        FOREIGN KEY (sentryId) REFERENCES userTable (userId)
        )
       """.update.run.transact(xa)

  val dropUserTable: IO[Int] = sql"""DROP TABLE IF EXISTS userTable CASCADE""".update.run.transact(xa)
  val dropUserTagTable: IO[Int] = sql"""DROP TABLE IF EXISTS userTagTable CASCADE""".update.run.transact(xa)
  val dropServiceTable: IO[Int] = sql"""DROP TABLE IF EXISTS serviceTable CASCADE""".update.run.transact(xa)
  val droServiceTagTable: IO[Int] = sql"""DROP TABLE IF EXISTS serviceTagTable CASCADE""".update.run.transact(xa)
  val dropServiceUserTable: IO[Int] = sql"""DROP TABLE IF EXISTS serviceUserTable CASCADE""".update.run.transact(xa)
  val dropFailureTable: IO[Int] = sql"""DROP TABLE IF EXISTS failureTable CASCADE""".update.run.transact(xa)
  val dropJobTable: IO[Int] = sql"""DROP TABLE IF EXISTS jobTable CASCADE""".update.run.transact(xa)
  val dropJobUserTable: IO[Int] = sql"""DROP TABLE IF EXISTS jobUserTable CASCADE""".update.run.transact(xa)
  val dropUserWithTelegramUserTable: IO[Int] = sql"""DROP TABLE IF EXISTS userWithTelegramChatTable CASCADE""".update.run.transact(xa)
  val dropTables: IO[Unit] = for {
    _ <- dropUserTable
    _ <- dropUserTagTable
    _ <- dropServiceTable
    _ <- droServiceTagTable
    _ <- dropServiceUserTable
    _ <- dropFailureTable
    _ <- dropJobTable
    _ <- dropJobUserTable
    _ <- dropJobUserTable
    _ <- dropUserWithTelegramUserTable
  } yield ()

}
